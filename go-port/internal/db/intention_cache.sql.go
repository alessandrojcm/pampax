// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: intention_cache.sql

package db

import (
	"context"
)

const getIntentionsByQuery = `-- name: GetIntentionsByQuery :many
SELECT
    id,
    query_normalized,
    original_query,
    target_sha,
    confidence,
    usage_count,
    created_at,
    last_used
FROM intention_cache
WHERE query_normalized = ?
ORDER BY usage_count DESC, last_used DESC
`

func (q *Queries) GetIntentionsByQuery(ctx context.Context, queryNormalized string) ([]IntentionCache, error) {
	rows, err := q.query(ctx, q.getIntentionsByQueryStmt, getIntentionsByQuery, queryNormalized)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IntentionCache{}
	for rows.Next() {
		var i IntentionCache
		if err := rows.Scan(
			&i.ID,
			&i.QueryNormalized,
			&i.OriginalQuery,
			&i.TargetSha,
			&i.Confidence,
			&i.UsageCount,
			&i.CreatedAt,
			&i.LastUsed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertIntention = `-- name: InsertIntention :exec
INSERT INTO intention_cache (
    query_normalized,
    original_query,
    target_sha,
    confidence,
    usage_count
) VALUES (?, ?, ?, ?, ?)
`

type InsertIntentionParams struct {
	QueryNormalized string   `json:"query_normalized"`
	OriginalQuery   string   `json:"original_query"`
	TargetSha       string   `json:"target_sha"`
	Confidence      *float64 `json:"confidence"`
	UsageCount      *int64   `json:"usage_count"`
}

func (q *Queries) InsertIntention(ctx context.Context, arg InsertIntentionParams) error {
	_, err := q.exec(ctx, q.insertIntentionStmt, insertIntention,
		arg.QueryNormalized,
		arg.OriginalQuery,
		arg.TargetSha,
		arg.Confidence,
		arg.UsageCount,
	)
	return err
}
